<!DOCTYPE html><html><head><meta charset="utf-8"/><link href="http://feeds.feedburner.com/suspended-chord/blog" rel="alternate" title="a-&gt;ab" type="application/rss+xml"/><link href="https://plus.google.com/114523146530319290209/posts" rel="author"/><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="/static/assets/packed.css" media="all" rel="stylesheet" type="text/css"/><script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
    </script><title>Adventures in Roguelike Development, Chapter 2: Gathering Supplies | a-&gt;ab</title></head><body><div class="container"><header><h1>a→ab</h1><h2>computation, game design, and experimentation</h2><br/> <a href="/">front page</a> | <a href="/about">about</a> | <a href="/archives">archives</a> | <a href="/code-dump">code dump</a> | <a href="/csmm">c.s. for mere mortals</a> | <a href="/tags">tags</a> | <span class="rss"><a href="http://feeds.feedburner.com/suspended-chord/blog">rss feed</a></span></header><section><div class="column"><article class="post"><header><h1>Adventures in Roguelike Development, Chapter 2: Gathering Supplies</h1><span class="date">May 28, 2011</span><br/> <span class="tags">tags: <a href="/tag/code-dump/">code-dump</a></span></header><section class="content"><p>Hello all,</p><p>Welcome to part two of my roguelike development journal. (You can read part 1 <a href="/?c=36">here</a>.) This week, I take a divergent path from the guide I started to follow in the first post, but only to get some important steps out of the way. And I even have a source snapshot for you! So, let's begin.</p><p>In the last post I mentioned that I was going to work on a random map generator. Well, I've decided to keep that until a later date. However, I have implemented most of the features that I will require to make that work at a base level. This week, I instead chose to focus on cleaning up the code and making it cross-platform from an early stage (and I hope to keep it that way) while implementing some minor features.</p><h2>New features</h2><p>Firstly, I added a scrolling message log, which is accessed when the user presses <code>M</code>. This outputs all of the messages that the player has received to the screen, starting at the most recent, and working up towards the beginning of the game. The user can scroll this list with <code>up arrow</code> and <code>down arrow</code> one line at a time, and arrows show up at the top right and bottom right of the screen indicating whether or not there are more messages to see. There is a screenshot at the end of the post to view this in action.</p><p>From then, I implemented room drawing (which is bugged, rooms end up being one more tile wide and tall than desired; I will fix it in the next week). To test this, I used randomly generated rooms (without regards to staying within the bounds of the map) and ended up with some interesting cases of collisons. And, as I now was spawing sometimes within solid rock, I decided to implement a <code>findInitialPosition()</code> method for the Player class, which looks randomly for an initial position that is not solid. So, at this point I had random rooms filling up a dungeon and I could walk around in them (and sometimes off the map due to how I handle collision).</p><p>After this, I added corridors and corridor drawing (which suffers the same bug as room drawing, in respects to length), and added doors to the ends of corridors. This is fine, but the player couldn't open doors yet, so I added that in as well. If the player tries to move onto a location occupied by a door, it is replaced by an open one, and a message is printed to the message buffer, and the player is moved. Simple as pie, but coded inflexibly. I'll touch this up in a later week.</p><p>Finally, I added a test map, just to check out if moving between rooms through corridors worked, and it did. The code snapshot below ships with this static map enabled. The player will start out in a random location every time, but the map will remain the same.</p><h2>Adventures in cross-platform coding</h2><p>I'm sad to say that most of the time that I spent this week was on getting the code to run on my Linux box as easily as it runs on my Windows machine. This was fairly easy due to rlutil's awesome capabilities, but I did hit a few speedbumps along the way. Since this game expects to be run in an 80x25 terminal, I modified the script that came with the Linux version of <a href="http://doom.chaosforge.org/">DoomRL</a> to run the program in an xterm window of the correct size. This is included in the snapshot as <code>rl_xterm</code>.</p><p>Due to my own stupidity, I was parsing input in a way that would work perfectly under Windows (due to the arrow keys being single keycodes rather than escape sequences as in *nix) but would fail miserably under Linux. When I first ran the game, it would exit every time an arrow key was pressed. This is partially due to the way that rlutil implements it's <code>rlutil::getkey()</code> method, which reads how many characters are waiting to be parsed, and then calls the blocking version of <code>getch()</code> on it. Essentially, if you call <code>getkey()</code> without checking first to see that there is input to parse, it will call <code>getch()</code>, and block, making it seem to act normally. But, because the buffer is checked before the call to <code>getch()</code>, the method won't know that there are multiple characters to be examined, and will just examine the first, which in the case of the arrow keys on Linux, end up being the escape character. On Windows, this problem didn't show up, thanks to the fact that arrow keys report one character on Windows machines. But, a simple empty while loop to check <code>kbhit()</code> before the call to <code>getkey()</code> saved the day.</p><p>And one more hurdle to jump, it seems that on Linux consoles, sometimes the output of keyboard interaction is echoed to the console. To work around this, I simply placed the cursor in a location that I know will be overwritten in the next frame. Simple, but kludgy. I'll look for other ways around this.</p><h2>A word on setting</h2><p>Lastly, I finally came up with a setting for this game. Well, actually two, but only one that I'm sharing with you. It will be an infinite rogue clone. Basically, a coffee break roguelike, you create a character and see just how many levels you can progress down the dungeons of doom/peril/strange sounds. There will be no end-game to speak of, just insane difficulties in lower levels, and maybe a shop every 20 floors or so to restock.</p><p>The other setting/game idea I have is much more interesting, but I want to try the basics first. :)</p><h2>A word on the code</h2><p>Thanks to the prodding of jimdoescode and hugoblack on <a href="http://reddit.com/r/roguelikedev">/r/roguelikedev</a>, I'm including a snapshot with each post from now on. The build instructions are simple, and should work on any system with a decent GCC installation (excepting Cygwin, rlutil won't compile on Cygwin witout serious modification, and MinGW works so much nicer anyway). Simply gunzip and untar the archive, and do a <code>make</code>. You might want to check your system's compatibility with rlutil first by running <code>make test &amp; ./rlutil-test</code>. Either way, the roguelike itself will be named <code>rl</code> (unique, huh?). If you're on a Linux box, I recommend running <code>./rl_xterm</code> to run it for now, but feel free to run it in anything you like. Oh, and I also included a small utility I used to test keycodes in rlutil. To compile it, run <code>make key</code>. It will check for input, and print out the keycode as they're pressed. <code>^C</code> to kill it. And as always, <code>make clean</code> will clean it all up for you.</p><p>The license is in the header of the <code>main.cpp</code> file, and rlutil is released under the <a href="http://tapio.github.com/rlutil/docs/License.txt">WTFPL</a>.</p><p>Screenshots:</p><p>the message buffer</p><p><img alt="message buffer" src="https://github.com/gatesphere/blog-resources/raw/master/downloads/images/roguelike/roguelike-messagebuffer.png"/></p><p>random rooms</p><p><img alt="random rooms" src="https://github.com/gatesphere/blog-resources/raw/master/downloads/images/roguelike/roguelike-randomrooms.png"/></p><p>random corridors</p><p><img alt="random corridors" src="https://github.com/gatesphere/blog-resources/raw/master/downloads/images/roguelike/roguelike-randomcorridors.png"/></p><p>test map</p><p><img alt="test map" src="https://github.com/gatesphere/blog-resources/raw/master/downloads/images/roguelike/roguelike-firstmap.png"/></p><p>Code: <a href="https://github.com/gatesphere/blog-resources/raw/master/downloads/source/rlprototype-20110528.tgz">snapshot 20110528</a></p><p>Keep tweaking~</p></section><section class="comments"><div id="disqus_thread"></div><script src="http://disqus.com/forums/suschord/embed.js" type="text/javascript"> </script><noscript>&lt;a href="http://suschord.disqus.com/?url=ref"&gt;View the discussion thread.&lt;/a&gt;</noscript><a class="dsq-brlink" href="http://disqus.com">blog comments powered by <span class="logo-disqus">Disqus</span></a></section></article></div></section><footer>a→ab is the blog of Jake Peck, also known as <a href="http://suspended-chord.info/">suspended-chord</a></footer><script type="text/javascript">
var disqus_shortname = 'suschord';
(function () {
  var s = document.createElement('script'); s.async = true;
  s.src = 'http://disqus.com/forums/suschord/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script></div></body></html>