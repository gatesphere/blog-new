<!DOCTYPE html><html><head><meta charset="utf-8"/><link href="http://feeds.feedburner.com/suspended-chord/blog" rel="alternate" title="a-&gt;ab" type="application/rss+xml"/><link href="https://plus.google.com/114523146530319290209/posts" rel="author"/><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="/static/assets/packed.css" media="all" rel="stylesheet" type="text/css"/><script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
    </script><title>CSMM - Lesson 1.3: Boolean Logic in the Lambda Calculus | a-&gt;ab</title></head><body><div class="container"><header><h1>a→ab</h1><h2>computation, game design, and experimentation</h2><br/> <a href="/">front page</a> | <a href="/about">about</a> | <a href="/archives">archives</a> | <a href="/code-dump">code dump</a> | <a href="/csmm">c.s. for mere mortals</a> | <a href="/tags">tags</a> | <span class="rss"><a href="http://feeds.feedburner.com/suspended-chord/blog">rss feed</a></span></header><section><div class="column"><article class="post"><header><h1>CSMM - Lesson 1.3: Boolean Logic in the Lambda Calculus</h1><span class="date">June 26, 2012</span><br/> <span class="tags">tags: <a href="/tag/csmm/">csmm</a>, <a href="/tag/lambda%20calculus/">lambda calculus</a>, <a href="/tag/boolean%20logic/">boolean logic</a>, <a href="/tag/predicates/">predicates</a>, <a href="/tag/logic/">logic</a></span></header><section class="content"><h2>Welcome back</h2><p>Last time we left off with basic arithmetic in the \(\lambda\)-calculus. In this lesson, we'll show the fundamental building blocks for boolean logic, which will be vitally important as we approach our first program! Let's get started.</p><h2>Truth values</h2><p>Before we get into the nitty gritty, I'm going to briefly explain the basics of boolean logic. If you have a good handle on mathematical logic, feel free to skip this section completely.</p><p>So, what is boolean logic? To be concise, it's the field of mathematical logich where every statement has a value of either true, or false, with no in between. Boolean logic, so named after George Boole, allows us to evalute the truth of statements by combining these truth values with very simple operators which have well-defined return values--in other words, functions.</p><p>So, we have two values (\(T\) for true, and \(F\) for false), and a number of operators. Which operators? We'll start with negation (\(\neg\)).</p><p>The \(\neg\) operator simply negates whatever it is applied to. \(\neg T = F\) and \(\neg F = T\). Simple, right?</p><p>The and (\(\land\)) operator takes two operands, and returns \(T\) only if both operands are \(T\), otherwise it returns \(F\). Here's all possible combinations:</p><p>$$T \land T = T$$ $$T \land F = F$$ $$F \land T = F$$ $$F \land F = F$$</p><p>The or (\(\lor\)) operator also takes two operands, and returns \(T\) if either of the operands are \(T\), or both are \(T\), and returns \(F\) only if both operands are \(F\). Here's the full defintion:</p><p>$$T \lor T = T$$ $$T \lor F = T$$ $$F \lor T = T$$ $$F \lor F = F$$</p><p>Using these three operators, we can figure out rather complex statements. For example:</p><p>$$\neg (T \land \neg ((T \lor F \lor T) \land F))$$ $$\neg (T \land \neg ((T \lor T) \land F))$$ $$\neg (T \land \neg (T \land F))$$ $$\neg (T \land \neg F)$$ $$\neg (T \land T)$$ $$\neg T$$ $$F$$</p><h2>Some abstraction</h2><p>So, now we're ready to start with boolean logic in the \(\lambda\)-calculus. A good place to start--indeed, the only place to start--is how to define the truth values. As with everything else in the \(\lambda\)-calculus, \(T\) and \(F\) are simply functions. And, as a bonus, you already know \(F\)!</p><p>$$F := \lambda xy.y$$ $$T := \lambda xy.x$$</p><p>As you might recall, \(0\) is defined as \(\lambda sz.z\), which is \(F\). \(T\) is pretty simple as well--Instead of returning it's second input, it returns the first, ignoring the second.</p><p>Now, let's define some operators.</p><h2>That's not me!</h2><p>As above, we'll start with negation.</p><p>$$\neg := \lambda x.xFT$$</p><p>We can see that this holds with the definition of negation. First, \(\neg T\):</p><p>$$\neg T$$ $$(\lambda x.xFT)T$$ $$TFT$$ $$(\lambda xy.x)FT$$ $$(\lambda y.F)T$$ $$F$$</p><p>And now \(\neg F\):</p><p>$$\neg F$$ $$(\lambda x.xFT)F$$ $$FFT$$ $$(\lambda xy.y)FT$$ $$(\lambda y.y)T$$ $$T$$</p><p>This definition is pretty clever. It uses the fact that both \(T\) and \(F\) return one of the two inputs they recieve. \(T\) returns the first input it recieves, so \(\neg\) makes sure that the first input will be \(F\). \(F\) on the other hand returns the second input it recieves, so \(\neg\) makes sure it will recieve \(T\) second. Simple, sweet, but functional and powerful.</p><h2>Don't forget me!</h2><p>How about and? And is defined as follows:</p><p>$$\land := \lambda xy.xyF$$</p><p>Let's test this out:</p><p>$$\land TT$$ $$(\lambda xy.xyF)TT$$ $$(\lambda y.TyF)T$$ $$TTF$$ $$(\lambda xy.x)TF$$ $$(\lambda y.T)F$$ $$T$$</p><p>How about another?</p><p>$$\land FT$$ $$(\lambda xy.xyF)FT$$ $$(\lambda y.FyF)T$$ $$FTF$$ $$(\lambda xy.y)TF$$ $$(\lambda y.y)F$$ $$F$$</p><p>I won't bore you with the other two cases, in fact, I'll let you work those out in the homework.</p><p>This function works in much the same way as \(\neg\) does, by relying upon the work that \(T\) and \(F\) do. If the first operand to \(\land\) is \(T\), then it will return whatever the second operand is. If the first operand to \(\land\) is \(F\), then it will always return \(F\). This ensures that the only time \(\land\) will return \(T\) is if both operands equal \(T\).</p><h2>Anyone at all?</h2><p>The third operator we need is or. Or is defined as follows:</p><p>$$\lor := \lambda xy.xTy$$</p><p>And, some examples:</p><p>$$\lor TT$$ $$(\lambda xy.xTy)TT$$ $$(\lambda y.TTy)T$$ $$TTT$$ $$(\lambda xy.x)TT$$ $$(\lambda y.T)T$$ $$T$$</p><p>And another: $$\lor FT$$ $$(\lambda xy.xTy)FT$$ $$(\lambda y.FTy)T$$ $$FTT$$ $$(\lambda xy.y)TT$$ $$(\lambda y.y)T$$ $$T$$</p><p>Again, the other two cases will be in your homework.</p><p>This function is analogous to \(\land\), in that it relies upon the first input to determine the return value. If the first input is \(T\), it returns \(T\) no matter what, and if the first input is \(F\), it returns the value of the second input. In this way, \(\lor\) will only return \(F\) if both inputs are \(F\).</p><h2>Wrapping up</h2><p>This lesson was rather short, but only because the next lesson will involve mixing boolean logic with arithmetic to create a few advanced functions, which will lead us to be able to define a subtraction function. But, enough about that. Your homework is available as a PDF <a href="https://github.com/gatesphere/blog-resources/raw/master/downloads/csmm/lesson1-3.pdf">here</a>. As always, questions on page 1 and answers on page 2.</p><p>See you soon for lesson 1.4!</p><p>Next lesson: <a href="/2012/06/29/csmm---lesson-14-advanced-logic-and-arithmetic-in-the-lambda-calculus/">here</a></p></section><section class="comments"><div id="disqus_thread"></div><script src="http://disqus.com/forums/suschord/embed.js" type="text/javascript"> </script><noscript>&lt;a href="http://suschord.disqus.com/?url=ref"&gt;View the discussion thread.&lt;/a&gt;</noscript><a class="dsq-brlink" href="http://disqus.com">blog comments powered by <span class="logo-disqus">Disqus</span></a></section></article></div></section><footer>a→ab is the blog of Jake Peck, also known as <a href="http://suspended-chord.info/">suspended-chord</a></footer><script type="text/javascript">
var disqus_shortname = 'suschord';
(function () {
  var s = document.createElement('script'); s.async = true;
  s.src = 'http://disqus.com/forums/suschord/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script></div></body></html>