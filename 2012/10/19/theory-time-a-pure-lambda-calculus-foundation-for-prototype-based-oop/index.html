<!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6610: * @file page.html-->
<!--@@language html-->
<!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6614: * @file base.html-->
<!--@@language html-->
<!doctype html>
<html>
<head>
  <meta charset="utf-8">

  
    
      <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6607: * @file _meta.html-->
<!--@@language html-->




<link rel="alternate" type="application/rss+xml" title="a-&gt;ab" href="http://feeds.feedburner.com/suspended-chord/blog">
<link rel="author" href="https://plus.google.com/114523146530319290209/posts">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
<!--@-leo-->
    
  

  <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6608: * @file _style.html-->
<!--@@language html-->


    <link href="/static/assets/packed.css" media="all" rel="stylesheet" type="text/css" />

<!--@-leo-->
  <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6605: * @file _js.html-->
<!--@@language html-->

    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
<!--@-leo-->

  <title>Theory Time - A pure lambda-calculus foundation for prototype-based OOP | a->ab</title>

</head>
<body>
  <div class="container">

  <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6604: * @file _header.html-->
<!--@@language html-->

<header>
  <h1>a&rarr;ab</h1><h2>computation, game design, and experimentation</h2><br />
  <a href="/">front page</a> | <a href="/about">about</a> | <a href="/archives">archives</a> | <a href="/code-dump">code dump</a> | <a href="/csmm">c.s. for mere mortals</a> | <a href="/tags">tags</a> | <span class='rss'><a href="http://feeds.feedburner.com/suspended-chord/blog">rss feed</a></span>
</header>
 
<!--@-leo-->

<section>
<div class="column">


  <article class="post">
  <header>
  <h1>Theory Time - A pure lambda-calculus foundation for prototype-based OOP</h1>
  <span class="date">October 19, 2012</span><br />
  <span class="tags">
    tags:&nbsp;
    
    <a href="/tag/theory/">theory</a>,&nbsp;
    
    <a href="/tag/lambda%20calculus/">lambda calculus</a>,&nbsp;
    
    <a href="/tag/lambda/">lambda</a>,&nbsp;
    
    <a href="/tag/prototype/">prototype</a>,&nbsp;
    
    <a href="/tag/oop/">oop</a>,&nbsp;
    
    <a href="/tag/map/">map</a>,&nbsp;
    
    <a href="/tag/list/">list</a>,&nbsp;
    
    <a href="/tag/hash/">hash</a>
    
  </span>
  </header>
  <section class="content">
    <p>Hello all,</p>
<p>I'm excited to write this post today, because it's something that just kind of 
flowed to me as I was thinking about programming language paradigms.  I was wondering
about just how deeply related functional programming is to other methodologies,
and figured that if the \(\lambda\)-calculus is Turing complete, there must be
a way to model object-orientation on some level with it.  What follows is my attempt
at forming a mathemtatical bridge between functional and object oriented programming
paradigms, by showing that OOP is really just a subset of the functionalities provided
by the \(\lambda\)-calculus.</p>
<h2>A bit of background</h2>
<p>Alright, I should probably start by defining a few things, such as what object model
I will be using, along with some notational conventions.</p>
<p>First, the object model.  I was looking for the absolute minimal model of what
an "object" is that I could use as a foundation for building in the \(\lambda\)-calculus.
It seems that a stripped down version of Io's object model fit the bill here.  In
Io, an object is just a collection of slots, each of which is a named reference to another
object.  There is no differentiation between classes and instances--everything is
a usable object.  And every new object extends and modifies a previously existing
object ("cloning" a "proto" in Io speak).  To interact with an object, you reference 
its slots by sending it a message, which acts as a key to an internal lookup table,
returning the value of the slot which is named the same as the message you sent.
So we have this graph-based relationship between objects tied together by names which
act as messages.  </p>
<p>This sounds to me like an easy thing to model abstractly.  We'll need some sort
of map to tie names to values, to act as an object's collection of slots.  We'll
also need a construct to bind that map to an ancestor object.  This construct will
be our object model.  To interact with it, we'll need some sort of a lookup method
to access the values from the map, and some sort of forwarding mechanism to look up
slots that were not found in the object in question's map, but may be in its
ancestor's slots.  And that, really, is all we need to model this.</p>
<p>But before I dive into details, let me explain my notation for the following
\(\lambda\)-terms a bit, as it does not follow the previous examples I've used
in this blog, simply for the sake of using more descriptive bound symbols.</p>
<p>Some conventions:</p>
<ul>
<li>Lowercase letters are variables, and are exactly one letter each.</li>
<li>Words in UPPERCASE are bound symbols, which are simply aliases for longer \(\lambda\)-terms.</li>
<li>Words in camelCase are the "interface" that I want to expose as the end result
    of this work.  They are otherwise functionally identical to UPPERCASE aliases.</li>
<li>Symbols will be separated with a space for readability.</li>
</ul>
<p>Also, for sake of easy editing, all terms will be typeset in a <code>fixed-width</code> font.</p>
<p>Alright, enough babbling, time to begin.</p>
<h2>\(\lambda\) foundations: a list</h2>
<p>This article assumes you know how to use church numerals, and the definitions for
a few common functions, such as SUCC, TRUE, FALSE, etc.  I will provide definitions
when I remember to, but if I'm missing something, I apologize.</p>
<p>Anyways, a quick and dirty explanation of a list in the \(\lambda\)-calculus
follows closely the implementation of a list in LISP, in that a list is either 
the empty list (NIL), or a pair consisting of an element and a smaller list.</p>
<p>We can use the following definitions for creating and manipulating lists:</p>
<div class="codehilite"><pre><span></span><code><span class="err">TRUE  := \a b.a</span>
<span class="err">FALSE := \a b.b</span>
<span class="err">CONS  := \a b f.f a b</span>
<span class="err">NIL   := \f.TRUE</span>
<span class="err">NIL?  := \l.l (\a b.FALSE)</span>
<span class="err">HEAD  := \l.l TRUE</span>
<span class="err">TAIL  := \l.l FALSE</span>
</code></pre></div>

<p>These functions are the building blocks for lists in the \(\lambda\)-calculus.</p>
<p>So, an example list could be:</p>
<div class="codehilite"><pre><span></span><code><span class="err">L := CONS a (CONS b (CONS c NIL))</span>
</code></pre></div>

<p>Some operations on this list could be:</p>
<div class="codehilite"><pre><span></span><code><span class="err">HEAD L                                   -&gt; a</span>
<span class="err">TAIL L                                   -&gt; CONS b (CONS c NIL)</span>
<span class="err">HEAD (TAIL L)                            -&gt; b</span>
<span class="err">NIL? (TAIL (TAIL (TAIL L)))              -&gt; TRUE</span>
<span class="err">NIL? L                                   -&gt; FALSE</span>
<span class="err">CONS (HEAD L) (CONS (HEAD (TAIL L)) NIL) -&gt; CONS a (CONS b NIL)</span>
</code></pre></div>

<p>Simple enough, right?</p>
<h2>Moving on to maps</h2>
<p>Defining a mapping construct in the \(\lambda\)-calculus is simple once you have
a definition for lists down.  A map is simply a list of pairs, each pair being
a pairing between a key and a value.</p>
<p>One issue with maps is that unless your keys are guaranteed to be unique, you'll
have some collisions, resulting in either maps with more values than keys, or missing
elements.  For simplicity, we'll limit our maps to single-valued maps, wherein each
key maps to exactly one value.</p>
<p>An example map could be:</p>
<div class="codehilite"><pre><span></span><code><span class="err">M := CONS (CONS 1 x) (CONS (CONS 5 y) NIL)</span>
</code></pre></div>

<p>So, here we have a map with 2 keys, here being Church numerals (you will see why
in a second), mapping to different values.</p>
<p>In order to make use of this map, we need a function to lookup the value related
to a given key.  This is why I chose Church numerals for the keys above--there
is an easily defined equality predicate for testing if two Church numerals are
the same.  Though, any class of \(\lambda\)-terms that you can define an equality
predicate for will work as the keys of a map.</p>
<p>The lookup function isn't to difficult to define:</p>
<div class="codehilite"><pre><span></span><code><span class="err">LOOKUP := \r m k.</span>
<span class="err">  IF (= (HEAD (HEAD m)) k)</span>
<span class="err">    (TAIL (HEAD m))</span>
<span class="err">    (IF (NIL? (TAIL m))</span>
<span class="err">      NIL</span>
<span class="err">      (r (TAIL m) k))</span>
</code></pre></div>

<p>That's a bit dense, but in pseudo-code, it reads a bit like this:</p>
<div class="codehilite"><pre><span></span><code><span class="err">lookup(map, key):</span>
<span class="err">  if (the head of the first element of map == key)</span>
<span class="err">    then [return the tail of the first element of map]</span>
<span class="err">    else [</span>
<span class="err">      if (the tail of map is the empty list)</span>
<span class="err">        then [return the empty list]</span>
<span class="err">        else [return lookup(tail(map), key)]</span>
<span class="err">    ]</span>
</code></pre></div>

<p>Actually using this involves the Y-combinator, a method of recursion in the \(\lambda\)-calculus:</p>
<div class="codehilite"><pre><span></span><code><span class="err">Y := \a.(\b.a (b b)) (\b.a (b b))</span>
</code></pre></div>

<p>To perform a lookup of key k on map m, do this:</p>
<div class="codehilite"><pre><span></span><code><span class="err">(Y LOOKUP) m k</span>
</code></pre></div>

<p>Easy as pie.</p>
<h2>The object model</h2>
<p>Our object construction is almost complete!  Now we just need to tie the map of
slots to an ancestor object in some construct, and define a getSlot function to
retrieve the value of a slot in an object or its ancestors.</p>
<p>Guess what it's going to be.</p>
<p>That's right, another pair.  We pair an ancestor to a map, and we have an object.
Pretty easy.</p>
<p>Here's an example object:</p>
<div class="codehilite"><pre><span></span><code><span class="err">O := CONS a (CONS (CONS 1 x) (CONS (CONS 5 y) NIL)</span>
</code></pre></div>

<p>For the getSlot function, we need to be able to find the value of some slot s
in either the object's slot map, or failing that (a value of NIL returned), in 
the slots of its ancestor object, recursing further if it isn't found there either.</p>
<p>A definition for this is pretty simple as well:</p>
<div class="codehilite"><pre><span></span><code><span class="err">GETSLOT := \r s o.</span>
<span class="err">  IF (NIL? ((Y LOOKUP) (TAIL o) s))</span>
<span class="err">    (IF (NIL? (HEAD o))</span>
<span class="err">      NIL</span>
<span class="err">      (r (HEAD o) s))</span>
<span class="err">    ((Y LOOKUP) (TAIL o) s)</span>
</code></pre></div>

<p>Again, pseudo-code for those who would like it:</p>
<div class="codehilite"><pre><span></span><code><span class="n">getslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">object</span><span class="p">)</span><span class="o">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">the</span> <span class="n">returned</span> <span class="n">value</span> <span class="k">for</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">object</span><span class="p">),</span> <span class="n">slot</span><span class="p">)</span> <span class="n">is</span> <span class="nb">nil</span><span class="p">)</span>
    <span class="n">then</span> <span class="p">[</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">object</span> <span class="n">is</span> <span class="nb">nil</span><span class="p">)</span>
        <span class="n">then</span> <span class="p">[</span><span class="k">return</span> <span class="nb">nil</span><span class="p">]</span>
        <span class="k">else</span> <span class="p">[</span><span class="k">return</span> <span class="n">getslot</span><span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="n">object</span><span class="p">),</span> <span class="n">slot</span><span class="p">)]</span>
    <span class="p">]</span>
    <span class="k">else</span> <span class="p">[</span><span class="k">return</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">object</span><span class="p">),</span><span class="n">slot</span><span class="p">)]</span>
</code></pre></div>

<p>Again, this makes use of the Y combinator, but because getSlot will be a part of
our clean interface to this model, I want to hide that detail for aesthetic
purposes.</p>
<div class="codehilite"><pre><span></span><code><span class="err">getSlot := Y GETSLOT</span>
</code></pre></div>

<p>And our model is complete!</p>
<h2>What this model does</h2>
<p>This model allows us to perform simple method chaining to adopt a very linear 
programming style.  Take the following line, for instance:</p>
<div class="codehilite"><pre><span></span><code><span class="err">a (getSlot 3) (getSlot 4) (getSlot 2)</span>
</code></pre></div>

<p>This would retrieve the slot 3 from object a, then retrieve that returned object's
4 slot, then finally retrieve that returned object's 2 slot.  This closely mirrors
the idea of message passing in prototype-based object-oriented languages.  Because
everything in the pure \(\lambda\)-calculus is a function, there is no such
thing as an exception in the above statement.  However, the end result might be
absolutely meaningless if one of those slots didn't exist along the way.</p>
<h2>What this model doesn't do</h2>
<p>Multiple inheritence, for a reason.  Which order would the ancestors be visited?
Besides, you can emulate multiple inheritance by creating multiple objects that
chain together dependencies.</p>
<p>Self referencing, as there's no introspection in the \(\lambda\)-calculus.  Though
it can be achieved in much the same fashion as with the Y combinator:</p>
<div class="codehilite"><pre><span></span><code><span class="err">a (getSlot 3) a</span>
</code></pre></div>

<p>That would pass a as a value to a's 3 slot.  Kind of python-like, but performed
manually.</p>
<p>Mutation, because I wanted to model this as a purely functional system, and further
wanted to stay strictly pure with my \(\lambda\)-terms.  Mutation is simply not
a concept that exists within the scope of this article.</p>
<h2>Final thoughts</h2>
<p>This was an interesting process of exploring and writing.  I'm not typically a theoretical
mathemetician, but something about the \(\lambda\)-calculus just gets me (as I'm
sure you've noticed).</p>
<p>Thanks for reading, and any suggestions/comments/criticisms are welcome in the comments
area below.</p>
  </section>
  <section class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript" src="http://disqus.com/forums/suschord/embed.js"> </script>
    <noscript><a href="http://suschord.disqus.com/?url=ref">View the discussion thread.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</article>

</div>
</section>

  <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6603: * @file _footer.html-->
<!--@@language html-->

<footer>
  a&rarr;ab is the blog of Jake Peck, also known as <a href="http://suspended-chord.info/">suspended-chord</a>
</footer>
<!--@-leo-->


  <!--@+leo-ver=5-thin-->
<!--@+node:peckj.20140121082121.6648: * @file _endjs.html-->
<!--@@language html-->

<script type="text/javascript">
var disqus_shortname = 'suschord';
(function () {
  var s = document.createElement('script'); s.async = true;
  s.src = 'http://disqus.com/forums/suschord/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<!--@-leo-->

  </div>
</body>
</html>

<!--@-leo-->