<!DOCTYPE html><html><head><meta charset="utf-8"/><link href="http://feeds.feedburner.com/suspended-chord/blog" rel="alternate" title="a-&gt;ab" type="application/rss+xml"/><link href="https://plus.google.com/114523146530319290209/posts" rel="author"/><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="/static/assets/packed.css" media="all" rel="stylesheet" type="text/css"/><script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
    </script><title>Theory Time - A pure lambda-calculus foundation for prototype-based OOP | a-&gt;ab</title></head><body><div class="container"><header><h1>a→ab</h1><h2>computation, game design, and experimentation</h2><br/> <a href="/">front page</a> | <a href="/about">about</a> | <a href="/archives">archives</a> | <a href="/code-dump">code dump</a> | <a href="/csmm">c.s. for mere mortals</a> | <a href="/tags">tags</a> | <span class="rss"><a href="http://feeds.feedburner.com/suspended-chord/blog">rss feed</a></span></header><section><div class="column"><article class="post"><header><h1>Theory Time - A pure lambda-calculus foundation for prototype-based OOP</h1><span class="date">October 19, 2012</span><br/> <span class="tags">tags: <a href="/tag/theory/">theory</a>, <a href="/tag/lambda%20calculus/">lambda calculus</a>, <a href="/tag/lambda/">lambda</a>, <a href="/tag/prototype/">prototype</a>, <a href="/tag/oop/">oop</a>, <a href="/tag/map/">map</a>, <a href="/tag/list/">list</a>, <a href="/tag/hash/">hash</a></span></header><section class="content"><p>Hello all,</p><p>I'm excited to write this post today, because it's something that just kind of flowed to me as I was thinking about programming language paradigms. I was wondering about just how deeply related functional programming is to other methodologies, and figured that if the \(\lambda\)-calculus is Turing complete, there must be a way to model object-orientation on some level with it. What follows is my attempt at forming a mathemtatical bridge between functional and object oriented programming paradigms, by showing that OOP is really just a subset of the functionalities provided by the \(\lambda\)-calculus.</p><h2>A bit of background</h2><p>Alright, I should probably start by defining a few things, such as what object model I will be using, along with some notational conventions.</p><p>First, the object model. I was looking for the absolute minimal model of what an "object" is that I could use as a foundation for building in the \(\lambda\)-calculus. It seems that a stripped down version of Io's object model fit the bill here. In Io, an object is just a collection of slots, each of which is a named reference to another object. There is no differentiation between classes and instances--everything is a usable object. And every new object extends and modifies a previously existing object ("cloning" a "proto" in Io speak). To interact with an object, you reference its slots by sending it a message, which acts as a key to an internal lookup table, returning the value of the slot which is named the same as the message you sent. So we have this graph-based relationship between objects tied together by names which act as messages.</p><p>This sounds to me like an easy thing to model abstractly. We'll need some sort of map to tie names to values, to act as an object's collection of slots. We'll also need a construct to bind that map to an ancestor object. This construct will be our object model. To interact with it, we'll need some sort of a lookup method to access the values from the map, and some sort of forwarding mechanism to look up slots that were not found in the object in question's map, but may be in its ancestor's slots. And that, really, is all we need to model this.</p><p>But before I dive into details, let me explain my notation for the following \(\lambda\)-terms a bit, as it does not follow the previous examples I've used in this blog, simply for the sake of using more descriptive bound symbols.</p><p>Some conventions:</p><ul><li>Lowercase letters are variables, and are exactly one letter each.</li><li>Words in UPPERCASE are bound symbols, which are simply aliases for longer \(\lambda\)-terms.</li><li>Words in camelCase are the "interface" that I want to expose as the end result of this work. They are otherwise functionally identical to UPPERCASE aliases.</li><li>Symbols will be separated with a space for readability.</li></ul><p>Also, for sake of easy editing, all terms will be typeset in a <code>fixed-width</code> font.</p><p>Alright, enough babbling, time to begin.</p><h2>\(\lambda\) foundations: a list</h2><p>This article assumes you know how to use church numerals, and the definitions for a few common functions, such as SUCC, TRUE, FALSE, etc. I will provide definitions when I remember to, but if I'm missing something, I apologize.</p><p>Anyways, a quick and dirty explanation of a list in the \(\lambda\)-calculus follows closely the implementation of a list in LISP, in that a list is either the empty list (NIL), or a pair consisting of an element and a smaller list.</p><p>We can use the following definitions for creating and manipulating lists:</p><div class="codehilite"><pre><span class="n">TRUE</span>  <span class="o">:=</span> <span class="err">\</span><span class="n">a</span> <span class="n">b</span><span class="p">.</span><span class="n">a</span>
<span class="n">FALSE</span> <span class="o">:=</span> <span class="err">\</span><span class="n">a</span> <span class="n">b</span><span class="p">.</span><span class="n">b</span>
<span class="n">CONS</span>  <span class="o">:=</span> <span class="err">\</span><span class="n">a</span> <span class="n">b</span> <span class="n">f</span><span class="p">.</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">NIL</span>   <span class="o">:=</span> <span class="err">\</span><span class="n">f</span><span class="p">.</span><span class="n">TRUE</span>
<span class="n">NIL</span><span class="o">?</span>  <span class="o">:=</span> <span class="err">\</span><span class="n">l</span><span class="p">.</span><span class="n">l</span> <span class="p">(</span><span class="err">\</span><span class="n">a</span> <span class="n">b</span><span class="p">.</span><span class="n">FALSE</span><span class="p">)</span>
<span class="n">HEAD</span>  <span class="o">:=</span> <span class="err">\</span><span class="n">l</span><span class="p">.</span><span class="n">l</span> <span class="n">TRUE</span>
<span class="n">TAIL</span>  <span class="o">:=</span> <span class="err">\</span><span class="n">l</span><span class="p">.</span><span class="n">l</span> <span class="n">FALSE</span>
</pre></div><p>These functions are the building blocks for lists in the \(\lambda\)-calculus.</p><p>So, an example list could be:</p><div class="codehilite"><pre><span class="n">L</span> <span class="o">:=</span> <span class="n">CONS</span> <span class="n">a</span> <span class="p">(</span><span class="n">CONS</span> <span class="n">b</span> <span class="p">(</span><span class="n">CONS</span> <span class="n">c</span> <span class="n">NIL</span><span class="p">))</span>
</pre></div><p>Some operations on this list could be:</p><div class="codehilite"><pre><span class="n">HEAD</span> <span class="n">L</span>                                   <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">TAIL</span> <span class="n">L</span>                                   <span class="o">-&gt;</span> <span class="n">CONS</span> <span class="n">b</span> <span class="p">(</span><span class="n">CONS</span> <span class="n">c</span> <span class="n">NIL</span><span class="p">)</span>
<span class="n">HEAD</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">L</span><span class="p">)</span>                            <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">NIL</span><span class="o">?</span> <span class="p">(</span><span class="n">TAIL</span> <span class="p">(</span><span class="n">TAIL</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">L</span><span class="p">)))</span>              <span class="o">-&gt;</span> <span class="n">TRUE</span>
<span class="n">NIL</span><span class="o">?</span> <span class="n">L</span>                                   <span class="o">-&gt;</span> <span class="n">FALSE</span>
<span class="n">CONS</span> <span class="p">(</span><span class="n">HEAD</span> <span class="n">L</span><span class="p">)</span> <span class="p">(</span><span class="n">CONS</span> <span class="p">(</span><span class="n">HEAD</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">L</span><span class="p">))</span> <span class="n">NIL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CONS</span> <span class="n">a</span> <span class="p">(</span><span class="n">CONS</span> <span class="n">b</span> <span class="n">NIL</span><span class="p">)</span>
</pre></div><p>Simple enough, right?</p><h2>Moving on to maps</h2><p>Defining a mapping construct in the \(\lambda\)-calculus is simple once you have a definition for lists down. A map is simply a list of pairs, each pair being a pairing between a key and a value.</p><p>One issue with maps is that unless your keys are guaranteed to be unique, you'll have some collisions, resulting in either maps with more values than keys, or missing elements. For simplicity, we'll limit our maps to single-valued maps, wherein each key maps to exactly one value.</p><p>An example map could be:</p><div class="codehilite"><pre><span class="n">M</span> <span class="o">:=</span> <span class="n">CONS</span> <span class="p">(</span><span class="n">CONS</span> <span class="mi">1</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">CONS</span> <span class="p">(</span><span class="n">CONS</span> <span class="mi">5</span> <span class="n">y</span><span class="p">)</span> <span class="n">NIL</span><span class="p">)</span>
</pre></div><p>So, here we have a map with 2 keys, here being Church numerals (you will see why in a second), mapping to different values.</p><p>In order to make use of this map, we need a function to lookup the value related to a given key. This is why I chose Church numerals for the keys above--there is an easily defined equality predicate for testing if two Church numerals are the same. Though, any class of \(\lambda\)-terms that you can define an equality predicate for will work as the keys of a map.</p><p>The lookup function isn't to difficult to define:</p><div class="codehilite"><pre><span class="n">LOOKUP</span> <span class="o">:=</span> <span class="err">\</span><span class="n">r</span> <span class="n">m</span> <span class="n">k</span><span class="p">.</span>
  <span class="n">IF</span> <span class="p">(</span><span class="o">=</span> <span class="p">(</span><span class="n">HEAD</span> <span class="p">(</span><span class="n">HEAD</span> <span class="n">m</span><span class="p">))</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">(</span><span class="n">TAIL</span> <span class="p">(</span><span class="n">HEAD</span> <span class="n">m</span><span class="p">))</span>
    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">NIL</span><span class="o">?</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">m</span><span class="p">))</span>
      <span class="n">NIL</span>
      <span class="p">(</span><span class="n">r</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">m</span><span class="p">)</span> <span class="n">k</span><span class="p">))</span>
</pre></div><p>That's a bit dense, but in pseudo-code, it reads a bit like this:</p><div class="codehilite"><pre><span class="nt">lookup</span><span class="o">(</span><span class="nt">map</span><span class="o">,</span> <span class="nt">key</span><span class="o">):</span>
  <span class="nt">if</span> <span class="o">(</span><span class="nt">the</span> <span class="nt">head</span> <span class="nt">of</span> <span class="nt">the</span> <span class="nt">first</span> <span class="nt">element</span> <span class="nt">of</span> <span class="nt">map</span> <span class="o">==</span> <span class="nt">key</span><span class="o">)</span>
    <span class="nt">then</span> <span class="cp">[</span><span class="k">return</span> <span class="nx">the</span> <span class="nx">tail</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nb">first</span> <span class="nb">element</span> <span class="nx">of</span> <span class="kt">map</span><span class="cp">]</span>
    <span class="nt">else</span> <span class="cp">[</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">the</span> <span class="nx">tail</span> <span class="nx">of</span> <span class="kt">map</span> <span class="nx">is</span> <span class="nx">the</span> <span class="nx">empty</span> <span class="nb">list</span><span class="p">)</span>
        <span class="nx">then</span> <span class="err">[</span><span class="k">return</span> <span class="nx">the</span> <span class="nx">empty</span> <span class="nb">list</span><span class="cp">]</span>
        <span class="nt">else</span> <span class="cp">[</span><span class="k">return</span> <span class="nx">lookup</span><span class="p">(</span><span class="nx">tail</span><span class="p">(</span><span class="kt">map</span><span class="p">),</span> <span class="nb">key</span><span class="p">)</span><span class="cp">]</span>
    <span class="o">]</span>
</pre></div><p>Actually using this involves the Y-combinator, a method of recursion in the \(\lambda\)-calculus:</p><div class="codehilite"><pre><span class="n">Y</span> <span class="o">:=</span> <span class="err">\</span><span class="n">a</span><span class="p">.(</span><span class="err">\</span><span class="n">b</span><span class="p">.</span><span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="err">\</span><span class="n">b</span><span class="p">.</span><span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="n">b</span><span class="p">))</span>
</pre></div><p>To perform a lookup of key k on map m, do this:</p><div class="codehilite"><pre><span class="p">(</span><span class="n">Y</span> <span class="n">LOOKUP</span><span class="p">)</span> <span class="n">m</span> <span class="n">k</span>
</pre></div><p>Easy as pie.</p><h2>The object model</h2><p>Our object construction is almost complete! Now we just need to tie the map of slots to an ancestor object in some construct, and define a getSlot function to retrieve the value of a slot in an object or its ancestors.</p><p>Guess what it's going to be.</p><p>That's right, another pair. We pair an ancestor to a map, and we have an object. Pretty easy.</p><p>Here's an example object:</p><div class="codehilite"><pre><span class="n">O</span> <span class="o">:=</span> <span class="n">CONS</span> <span class="n">a</span> <span class="p">(</span><span class="n">CONS</span> <span class="p">(</span><span class="n">CONS</span> <span class="mi">1</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">CONS</span> <span class="p">(</span><span class="n">CONS</span> <span class="mi">5</span> <span class="n">y</span><span class="p">)</span> <span class="n">NIL</span><span class="p">)</span>
</pre></div><p>For the getSlot function, we need to be able to find the value of some slot s in either the object's slot map, or failing that (a value of NIL returned), in the slots of its ancestor object, recursing further if it isn't found there either.</p><p>A definition for this is pretty simple as well:</p><div class="codehilite"><pre><span class="n">GETSLOT</span> <span class="o">:=</span> <span class="err">\</span><span class="n">r</span> <span class="n">s</span> <span class="n">o</span><span class="p">.</span>
  <span class="n">IF</span> <span class="p">(</span><span class="n">NIL</span><span class="o">?</span> <span class="p">((</span><span class="n">Y</span> <span class="n">LOOKUP</span><span class="p">)</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">o</span><span class="p">)</span> <span class="n">s</span><span class="p">))</span>
    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">NIL</span><span class="o">?</span> <span class="p">(</span><span class="n">HEAD</span> <span class="n">o</span><span class="p">))</span>
      <span class="n">NIL</span>
      <span class="p">(</span><span class="n">r</span> <span class="p">(</span><span class="n">HEAD</span> <span class="n">o</span><span class="p">)</span> <span class="n">s</span><span class="p">))</span>
    <span class="p">((</span><span class="n">Y</span> <span class="n">LOOKUP</span><span class="p">)</span> <span class="p">(</span><span class="n">TAIL</span> <span class="n">o</span><span class="p">)</span> <span class="n">s</span><span class="p">)</span>
</pre></div><p>Again, pseudo-code for those who would like it:</p><div class="codehilite"><pre><span class="n">getslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">object</span><span class="p">)</span><span class="o">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">the</span> <span class="n">returned</span> <span class="n">value</span> <span class="k">for</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">object</span><span class="p">),</span> <span class="n">slot</span><span class="p">)</span> <span class="n">is</span> <span class="nb">nil</span><span class="p">)</span>
    <span class="n">then</span> <span class="p">[</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">object</span> <span class="n">is</span> <span class="nb">nil</span><span class="p">)</span>
        <span class="n">then</span> <span class="p">[</span><span class="k">return</span> <span class="nb">nil</span><span class="p">]</span>
        <span class="k">else</span> <span class="p">[</span><span class="k">return</span> <span class="n">getslot</span><span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="n">object</span><span class="p">),</span> <span class="n">slot</span><span class="p">)]</span>
    <span class="p">]</span>
    <span class="k">else</span> <span class="p">[</span><span class="k">return</span> <span class="n">lookup</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">object</span><span class="p">),</span><span class="n">slot</span><span class="p">)]</span>
</pre></div><p>Again, this makes use of the Y combinator, but because getSlot will be a part of our clean interface to this model, I want to hide that detail for aesthetic purposes.</p><div class="codehilite"><pre><span class="n">getSlot</span> <span class="o">:=</span> <span class="n">Y</span> <span class="n">GETSLOT</span>
</pre></div><p>And our model is complete!</p><h2>What this model does</h2><p>This model allows us to perform simple method chaining to adopt a very linear programming style. Take the following line, for instance:</p><div class="codehilite"><pre><span class="n">a</span> <span class="p">(</span><span class="n">getSlot</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">getSlot</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="n">getSlot</span> <span class="mi">2</span><span class="p">)</span>
</pre></div><p>This would retrieve the slot 3 from object a, then retrieve that returned object's 4 slot, then finally retrieve that returned object's 2 slot. This closely mirrors the idea of message passing in prototype-based object-oriented languages. Because everything in the pure \(\lambda\)-calculus is a function, there is no such thing as an exception in the above statement. However, the end result might be absolutely meaningless if one of those slots didn't exist along the way.</p><h2>What this model doesn't do</h2><p>Multiple inheritence, for a reason. Which order would the ancestors be visited? Besides, you can emulate multiple inheritance by creating multiple objects that chain together dependencies.</p><p>Self referencing, as there's no introspection in the \(\lambda\)-calculus. Though it can be achieved in much the same fashion as with the Y combinator:</p><div class="codehilite"><pre><span class="n">a</span> <span class="p">(</span><span class="n">getSlot</span> <span class="mi">3</span><span class="p">)</span> <span class="n">a</span>
</pre></div><p>That would pass a as a value to a's 3 slot. Kind of python-like, but performed manually.</p><p>Mutation, because I wanted to model this as a purely functional system, and further wanted to stay strictly pure with my \(\lambda\)-terms. Mutation is simply not a concept that exists within the scope of this article.</p><h2>Final thoughts</h2><p>This was an interesting process of exploring and writing. I'm not typically a theoretical mathemetician, but something about the \(\lambda\)-calculus just gets me (as I'm sure you've noticed).</p><p>Thanks for reading, and any suggestions/comments/criticisms are welcome in the comments area below.</p></section><section class="comments"><div id="disqus_thread"></div><script src="http://disqus.com/forums/suschord/embed.js" type="text/javascript"> </script><noscript>&lt;a href="http://suschord.disqus.com/?url=ref"&gt;View the discussion thread.&lt;/a&gt;</noscript><a class="dsq-brlink" href="http://disqus.com">blog comments powered by <span class="logo-disqus">Disqus</span></a></section></article></div></section><footer>a→ab is the blog of Jake Peck, also known as <a href="http://suspended-chord.info/">suspended-chord</a></footer><script type="text/javascript">
var disqus_shortname = 'suschord';
(function () {
  var s = document.createElement('script'); s.async = true;
  s.src = 'http://disqus.com/forums/suschord/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script></div></body></html>